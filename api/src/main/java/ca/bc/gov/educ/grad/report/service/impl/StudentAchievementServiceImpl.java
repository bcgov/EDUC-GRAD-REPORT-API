/*
 * *********************************************************************
 *  Copyright (c) 2017, Ministry of Education and Child Care, BC.
 *
 *  All rights reserved.
 *    This information contained herein may not be used in whole
 *    or in part without the express written consent of the
 *    Government of British Columbia, Canada.
 *
 *  Revision Control Information
 *  File:                $Id::                                                 $
 *  Date of Last Commit: $Date::                                               $
 *  Revision Number:     $Rev::                                                $
 *  Last Commit by:      $Author::                                             $
 *
 * ***********************************************************************
 */
package ca.bc.gov.educ.grad.report.service.impl;

import ca.bc.gov.educ.grad.report.api.client.ReportData;
import ca.bc.gov.educ.grad.report.dao.GradDataConvertionBean;
import ca.bc.gov.educ.grad.report.dao.ReportRequestDataThreadLocal;
import ca.bc.gov.educ.grad.report.dto.impl.*;
import ca.bc.gov.educ.grad.report.exception.EntityNotFoundException;
import ca.bc.gov.educ.grad.report.model.achievement.*;
import ca.bc.gov.educ.grad.report.model.assessment.AssessmentResult;
import ca.bc.gov.educ.grad.report.model.common.DataException;
import ca.bc.gov.educ.grad.report.model.common.DomainServiceException;
import ca.bc.gov.educ.grad.report.model.graduation.*;
import ca.bc.gov.educ.grad.report.model.reports.*;
import ca.bc.gov.educ.grad.report.model.student.PersonalEducationNumber;
import ca.bc.gov.educ.grad.report.model.student.StudentInfo;
import ca.bc.gov.educ.grad.report.model.transcript.Course;
import ca.bc.gov.educ.grad.report.model.transcript.GraduationData;
import ca.bc.gov.educ.grad.report.service.GradReportCodeService;
import jakarta.annotation.security.DeclareRoles;
import jakarta.annotation.security.RolesAllowed;
import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.CompareToBuilder;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.InputStream;
import java.text.NumberFormat;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import static ca.bc.gov.educ.grad.report.dto.impl.constants.Roles.STUDENT_ACHIEVEMENT_REPORT;
import static ca.bc.gov.educ.grad.report.model.common.support.VerifyUtils.nullSafe;
import static ca.bc.gov.educ.grad.report.model.common.support.impl.Roles.FULFILLMENT_SERVICES_USER;
import static ca.bc.gov.educ.grad.report.model.common.support.impl.Roles.USER;
import static ca.bc.gov.educ.grad.report.model.course.ReportCourseType.ASSESSMENT;
import static ca.bc.gov.educ.grad.report.model.course.ReportCourseType.PROVINCIALLY_EXAMINABLE;
import static ca.bc.gov.educ.grad.report.model.reports.ReportFormat.PDF;
import static java.text.NumberFormat.getIntegerInstance;
import static org.apache.commons.lang3.ArrayUtils.isEmpty;

/**
 * The achievement service is an implementation component of the broader
 * Achievement Services group. As part of the mid-tier service layer the
 * buildReport method called by the GUI (browser) to display the unofficial
 * achievement of grades. The display is a rendered report generated by the
 * report service populated with data from the TRAX adaptor for the current user
 * as determined by the student demographics service.
 * <p>
 * This service integrates with the Student Demographics, the TRAX adaptor, and
 * the Reporting Service.
 * </p>
 * <p>
 * The security roles required to build a achievement report are:
 * <ol>
 * <li>XS_REPORT</li>
 * <li>TRAX_READ</li>
 * <li>SXR_READ</li>
 * <li>SXR_SEARCH</li>
 * <li>USER_REPORTS_EXPORT</li>
 * <li>USER_REPORTS_TRANSCRIPT</li>
 * <li>USER_PROFILE_SEARCH</li>
 * <li>USER_PROFILE_READ</li>
 * <li>USER</li>
 * </ol>
 *
 * @author CGI Information Management Consultants Inc.
 */
@Service
@DeclareRoles({STUDENT_ACHIEVEMENT_REPORT, USER, FULFILLMENT_SERVICES_USER})
public class StudentAchievementServiceImpl extends GradReportServiceImpl implements StudentAchievementService {

    private static final long serialVersionUID = 5L;

    private static final String CLASSNAME = StudentAchievementServiceImpl.class.getName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);
    private static final String REPORT_DATA_MISSING = "REPORT_DATA_MISSING";

    /**
     * Sort order for ungraded courses (to bottom, above assessments).
     */
    private static final String SORT_UNGRADED = "99";

    /**
     * Sort order for assessments (to bottom, below ungraded).
     */
    private static final String SORT_ASSESSMENT = "100";

    private final String FORMAT_COURSE_CODE = "%-5s";
    private final String FORMAT_COURSE_LEVEL = "%-3s";

    @Autowired
    private ReportService reportService;
    @Autowired
    private GradReportCodeService codeService;

    @Autowired
    GradDataConvertionBean gradDataConvertionBean;

    /**
     * Creates the student's official achievement as a PDF (no other formats are
     * allowed for official achievements).
     *
     * @return A filled achievement report suitable for sending to a PSI.
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    @Override
    @RolesAllowed({STUDENT_ACHIEVEMENT_REPORT, USER})
    public StudentAchievementReport buildOfficialAchievementReport()
            throws DomainServiceException, IOException, DataException {
        return createAchievementReport(PDF, false, false);
    }

    /**
     * @param studentID
     */
    public void deleteStudentReportByStudentID(String studentID) {
        gradDataConvertionBean.deleteStudentReportByStudentID(studentID);
    }

    /**
     * Builds an unofficial achievement report.
     *
     * @param format PDF, HTML, etc.
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    @Override
    @RolesAllowed({STUDENT_ACHIEVEMENT_REPORT, USER})
    public StudentAchievementReport buildAchievementReport(
            final ReportFormat format)
            throws DomainServiceException, IOException, DataException {
        return buildAchievementReport(format, false);
    }

    /**
     * Builds an unofficial achievement report.
     *
     * @param format PDF, HTML, etc.
     * @param pen    student identifier.
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    @Override
    @RolesAllowed({STUDENT_ACHIEVEMENT_REPORT})
    public StudentAchievementReport buildAchievementReport(
            final ReportFormat format, final PersonalEducationNumber pen, final Parameters parameters, final boolean interim)
            throws DomainServiceException, IOException, DataException {
        return createAchievementReport(format, true, pen, parameters, interim);
    }

    /**
     * Builds an unofficial achievement report asynchronously. Calls
     * <code>createAchievementReport(ReportFormat, true)</code> and returns the
     * result wrapped in an AsyncResult.
     *
     * @param format PDF, HTML, etc.
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    @Override
    @RolesAllowed({STUDENT_ACHIEVEMENT_REPORT, USER})
    public Future<StudentAchievementReport> buildAchievementReportAsync(
            final ReportFormat format)
            throws DomainServiceException, IOException, DataException {
        return new AsyncResult<>(createAchievementReport(format, true, false));
    }

    private GradProgram createGradProgram(String code) {
        final String methodName = "createGradProgram(String code)";
        LOG.entering(CLASSNAME, methodName);

        if (StringUtils.trimToNull(code) == null) {
            code = GraduationProgramCode.PROGRAM_2018.getCode();
        }

        ReportData reportData = ReportRequestDataThreadLocal.getReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    getClass(),
                    REPORT_DATA_MISSING,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, methodName, dse);
            throw dse;
        }

        if (reportData.getGradProgram() == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    getClass(),
                    "GRAD_PROGRAM_MISSING",
                    "Graduation Program not exists for the current report generation");
            LOG.throwing(CLASSNAME, methodName, dse);
            throw dse;
        }

        return new GradProgramImpl(GraduationProgramCode.valueFrom(
                code,
                reportData.getGradProgram().getCode().getDescription()));
    }

    /**
     * Creates a report in a specific format, either official or unofficial,
     * depending on the preview value.
     *
     * @param format
     * @param preview Set to false to create an unofficial achievement
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    private StudentAchievementReport createAchievementReport(
            final ReportFormat format,
            final boolean preview, final boolean interim)
            throws DomainServiceException, IOException, DataException {
        final String methodName = "createAchievement(ReportFormat, boolean)";
        LOG.entering(CLASSNAME, methodName);

        final PersonalEducationNumber pen = getStudentPEN();
        LOG.log(Level.FINE, "Retrieved studentInfo for pen: {0}.", pen.getValue());

        final StudentAchievementReport report = getStudentAchievementReport(
                pen, format, preview, null, interim
        );
        LOG.exiting(CLASSNAME, methodName);
        return report;
    }

    /**
     * Creates a report in a specific format, either official or unofficial,
     * depending on the preview value. Takes the PEN to generate the desired
     * report.
     *
     * @param format
     * @param preview Set to false to create an unofficial achievement
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    private StudentAchievementReport createAchievementReport(
            final ReportFormat format,
            final boolean preview, final PersonalEducationNumber pen, final Parameters parameters, final boolean interim)
            throws DomainServiceException, IOException, DataException {
        final String methodName = "createAchievement(ReportFormat, boolean)";
        LOG.entering(CLASSNAME, methodName);
        LOG.log(Level.FINE, "Retrieved achievement for pen: {0}.", pen.getValue());

        final StudentAchievementReport report = getStudentAchievementReport(pen, format, preview, parameters, interim);
        LOG.log(Level.FINE, "Created StudentAchievementReport for pen: {0}.", pen.getValue());

        LOG.exiting(CLASSNAME, methodName);
        return report;
    }

    /**
     * Read the collection of achievement courses from the TRAX Adaptor which is
     * required for the achievement service.
     *
     * @param pen Student identifier.
     * @return
     */
    private List<AchievementCourse> getAchievementCourseList(
            final String pen, final boolean interim)
            throws DataException, DomainServiceException {
        final String m_ = "getAchievementCourseList(String, boolean)";
        LOG.entering(CLASSNAME, m_);

        final List<AchievementCourse> results;

        ReportData reportData = ReportRequestDataThreadLocal.getReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    getClass(),
                    REPORT_DATA_MISSING,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, m_, dse);
            throw dse;
        }

        results = gradDataConvertionBean.getAchievementCourses(reportData);

        LOG.log(Level.FINE,
                "Retrieved the collection of exam results from TRAX for PEN: {0} INTERIM: {1}",
                new Object[]{pen, interim});

        if (results != null && !results.isEmpty()) {
            LOG.log(Level.FINE,
                    "Total courses {0} retrieved  for PEN: {1}",
                    new Object[]{results.size(), pen});
            LOG.log(Level.FINEST, "Retrieved student achievement course results:");
            for (AchievementCourse result : results) {
                LOG.log(Level.FINEST, "{0} {1}",
                        new Object[]{result.getCourseName(), result.getFinalLetterGrade()});
            }
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, m_);
        return results;
    }

    /**
     * Read the collection of achievement courses from the Adaptor which is
     * required for the achievement service.
     *
     * @param pen Student identifier.
     * @return
     */
    private List<AssessmentResult> getAssessmentResultList(
            final String pen)
            throws DataException, DomainServiceException {
        final String m_ = "getAssessmentList(String, boolean)";
        LOG.entering(CLASSNAME, m_);

        final List<AssessmentResult> results;

        LOG.log(Level.FINE,
                "Retrieved the collection of exam results from TRAX for PEN: {0}",
                new Object[]{pen});

        ReportData reportData = ReportRequestDataThreadLocal.getReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    getClass(),
                    REPORT_DATA_MISSING,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, m_, dse);
            throw dse;
        }

        List<AssessmentResult> resultsList = gradDataConvertionBean.getAssessmentCourses(reportData);
        results = new ArrayList<>();
        for (AssessmentResult course : resultsList) {
            results.add(course);
        }

        if (results != null && !results.isEmpty()) {
            LOG.log(Level.FINE,
                    "Total courses {0} retrieved  for PEN: {1}",
                    new Object[]{results.size(), pen});
            LOG.log(Level.FINEST, "Retrieved student achievement course results:");
            for (AssessmentResult result : results) {
                LOG.log(Level.FINEST, "{0} {1}",
                        new Object[]{result.getAssessmentCode(), result.getProficiencyScore()});
            }
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, m_);
        return results;
    }

    /**
     * Read the collection of achievement courses from the Adaptor which is
     * required for the achievement service.
     *
     * @param pen Student identifier.
     * @return
     */
    private GraduationStatus getGraduationStatus(
            final String pen)
            throws DataException, DomainServiceException {
        final String m_ = "getAssessmentList(String, boolean)";
        LOG.entering(CLASSNAME, m_);

        final GraduationStatus result;

        LOG.log(Level.FINE,
                "Retrieved the collection of exam results from TRAX for PEN: {0}",
                new Object[]{pen});

        ReportData reportData = ReportRequestDataThreadLocal.getReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    getClass(),
                    REPORT_DATA_MISSING,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, m_, dse);
            throw dse;
        }

        result = new GraduationStatusImpl();
        BeanUtils.copyProperties(reportData.getGraduationStatus(), result);

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, m_);
        return result;
    }

    /**
     * Read the collection of student exams from the Adaptor which is
     * required for the achievement service.
     *
     * @param pen Student identifier.
     * @return
     */
    private List<Exam> getStudentExamList(
            final String pen)
            throws DataException, DomainServiceException {
        final String m_ = "getAssessmentList(String, boolean)";
        LOG.entering(CLASSNAME, m_);

        final List<Exam> results;

        LOG.log(Level.FINE,
                "Retrieved the collection of exam results from TRAX for PEN: {0}",
                new Object[]{pen});

        ReportData reportData = ReportRequestDataThreadLocal.getReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    getClass(),
                    REPORT_DATA_MISSING,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, m_, dse);
            throw dse;
        }

        List<Exam> resultsList = gradDataConvertionBean.getStudentExams(reportData);
        results = new ArrayList<>();
        for (Exam exam : resultsList) {
            results.add(exam);
        }

        if (results != null && !results.isEmpty()) {
            LOG.log(Level.FINE,
                    "Total exam {0} retrieved  for PEN: {1}",
                    new Object[]{results.size(), pen});
            LOG.log(Level.FINEST, "Retrieved student exam results:");
            for (Exam result : results) {
                LOG.log(Level.FINEST, "{0} {1}",
                        new Object[]{result.getCourseCode(), result.getBestExamPercent()});
            }
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, m_);
        return results;
    }

    /**
     * Read the collection of student exams from the Adaptor which is
     * required for the achievement service.
     *
     * @param pen Student identifier.
     * @return
     */
    private List<OptionalProgram> getOptionalProgramList(
            final String pen)
            throws DataException, DomainServiceException {
        final String m_ = "getOptionalProgramList(String)";
        LOG.entering(CLASSNAME, m_);

        final List<OptionalProgram> results;

        LOG.log(Level.FINE,
                "Retrieved the collection of exam results from TRAX for PEN: {0}",
                new Object[]{pen});

        ReportData reportData = ReportRequestDataThreadLocal.getReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    getClass(),
                    REPORT_DATA_MISSING,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, m_, dse);
            throw dse;
        }

        List<OptionalProgram> resultsList = gradDataConvertionBean.getOptionalPrograms(reportData);
        results = new ArrayList<>();
        for (OptionalProgram exam : resultsList) {
            results.add(exam);
        }

        if (results != null && !results.isEmpty()) {
            LOG.log(Level.FINE,
                    "Total exam {0} retrieved  for PEN: {1}",
                    new Object[]{results.size(), pen});
            LOG.log(Level.FINEST, "Retrieved student optional program results:");
            for (OptionalProgram result : results) {
                LOG.log(Level.FINEST, "{0} {1}",
                        new Object[]{result.getOptionalProgramCode(), result.getOptionalProgramName()});
            }
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, m_);
        return results;
    }

    private List<String> getCareerProgramList(
            final String pen)
            throws DataException, DomainServiceException {
        final String m_ = "getCareerProgramList(String)";
        LOG.entering(CLASSNAME, m_);

        final List<String> results;

        LOG.log(Level.FINE,
                "Retrieved the collection of career program results from TRAX for PEN: {0}",
                new Object[]{pen});

        ReportData reportData = ReportRequestDataThreadLocal.getReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    getClass(),
                    REPORT_DATA_MISSING,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, m_, dse);
            throw dse;
        }

        results = this.gradDataConvertionBean.getCareerPrograms(reportData);

        if (results != null && !results.isEmpty()) {
            LOG.log(Level.FINE,
                    "Total carrier programs {0} retrieved  for PEN: {1}",
                    new Object[]{results.size(), pen});
            LOG.log(Level.FINEST, "Retrieved student career program results:");
            for (String result : results) {
                LOG.log(Level.FINEST, "{0}", new Object[]{result});
            }
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, m_);
        return results;
    }

    /**
     * Convert non-graduation reasons from a TRAX map to an STs list.
     *
     * @param student The student instance that has non-grad reasons to
     *                convert.
     * @return The map of non-grad reasons converted from a map to a list of
     * NonGradReasons instances.
     */
    private List<NonGradReason> adaptReasons(final StudentInfo student) {
        final String methodName = "adaptReasons(StudentInfo)";
        LOG.entering(CLASSNAME, methodName);

        final Map<String, String> gradReasons = student.getNonGradReasons();
        final List<NonGradReason> reasons = new ArrayList<>();

        for (Map.Entry<String, String> entry : gradReasons.entrySet()) {
            final String key = entry.getKey();
            final String value = entry.getValue();
            NonGradReasonImpl r = new NonGradReasonImpl();
            r.setCode(key);
            r.setDescription(value);
            reasons.add(r);
        }

        LOG.exiting(CLASSNAME, methodName);
        return reasons;
    }

    /**
     * Create an unofficial achievement of grades report.
     *
     * @param reportFormat
     * @param preview
     * @return
     * @throws DomainServiceException
     */
    private synchronized StudentAchievementReport createReport(
            final ReportFormat reportFormat,
            final boolean preview,
            final Parameters parameters,
            final boolean interim,
            final String gradProgram) throws DomainServiceException {
        final String methodName = "createReport(...)";
        LOG.entering(CLASSNAME, methodName);

        final AchievementReport report = reportService.createAchievementReport();

        if (parameters != null) {
            report.setParameters(parameters);
        }

        // Indicate official/unofficial
        report.setPreview(preview);
        report.setFormat(reportFormat);
        report.setInterim(interim);
        report.setGraduationProgram(createGradProgram(gradProgram));

        final ReportDocument document;

        try {
            document = reportService.export(report);
        } catch (final Exception ex) {
            final String msg = "Failed to create report.";
            LOG.log(Level.SEVERE, msg, ex);
            final DomainServiceException dse = new DomainServiceException(msg, ex);
            LOG.throwing(CLASSNAME, methodName, dse);
            throw dse;
        }

        final String filename = report.getFilename();
        final byte[] content = document.asBytes();

        if (isEmpty(content)) {
            final String msg = "The generated report output is empty.";
            DomainServiceException dse = new DomainServiceException(msg);
            LOG.throwing(CLASSNAME, methodName, dse);
            throw dse;
        }

        final StudentAchievementReport achievementReport = new StudentAchievementReportImpl(
                content, reportFormat, filename, "Achievement"
        );
        LOG.log(Level.FINE, "Created StudentAchievementReport {0}.", new Object[]{achievementReport});

        LOG.exiting(CLASSNAME, methodName);
        return achievementReport;
    }

    private StudentAchievementReport getStudentAchievementReport(
            final PersonalEducationNumber personalEducationNumber,
            final ReportFormat format,
            final boolean preview,
            Parameters parameters,
            final boolean interim) throws DomainServiceException, IOException {
        final String methodName = "getStudentAchievementReport(String, ReportFormat, boolean, Parameters, boolean)";
        LOG.entering(CLASSNAME, methodName);

        if (parameters == null) {
            parameters = createParameters();
        }

        String pen = personalEducationNumber.getPen();
        StudentInfo studentInfo = getStudentInfo(personalEducationNumber.getPen());

        String gradReqYear = studentInfo.getGradReqYear();
        StudentInfoImpl studentInfoImpl = (StudentInfoImpl) studentInfo;
        studentInfoImpl.setGradProgram(createGradProgram(gradReqYear).getCode().getDescription());

        List<Exam> sExamObjList = getStudentExamList(pen);
        parameters.put("hasStudentExam", "false");
        if (!sExamObjList.isEmpty()) {
            JRBeanCollectionDataSource jrBeanCollectionDataSource = new JRBeanCollectionDataSource(sExamObjList);
            parameters.put("studentExam", jrBeanCollectionDataSource);
            parameters.put("hasStudentExam", "true");
        }

        List<AchievementCourse> sCourseObjList = getAchievementCourseList(pen, interim);
        parameters.put("hasStudentCourse", "false");
        if (!sCourseObjList.isEmpty()) {
            JRBeanCollectionDataSource jrBeanCollectionDataSource = new JRBeanCollectionDataSource(sCourseObjList);
            parameters.put("studentCourse", jrBeanCollectionDataSource);
            parameters.put("hasStudentCourse", "true");
        }

        List<AssessmentResult> sAssessmentObjList = this.getAssessmentResultList(pen);
        parameters.put("hasStudentAssessment", "false");
        if (!sAssessmentObjList.isEmpty()) {
            JRBeanCollectionDataSource jrBeanCollectionDataSource = new JRBeanCollectionDataSource(sAssessmentObjList);
            parameters.put("studentAssessment", jrBeanCollectionDataSource);
            parameters.put("hasStudentAssessment", "true");
        }

        List<ca.bc.gov.educ.grad.report.model.graduation.NonGradReason> nongradList = adaptReasons(studentInfo);
        parameters.put("hasNonGradReasons", "false");
        if (!nongradList.isEmpty()) {
            JRBeanCollectionDataSource jrBeanCollectionDataSource = new JRBeanCollectionDataSource(nongradList);
            parameters.put("nonGradReason", jrBeanCollectionDataSource);
            parameters.put("hasNonGradReasons", "true");
        }

        List<OptionalProgram> optionalProgramList = this.getOptionalProgramList(pen);
        parameters.put("hasOptionalPrograms", "false");
        if (!optionalProgramList.isEmpty()) {
            JRBeanCollectionDataSource jrBeanCollectionDataSource = new JRBeanCollectionDataSource(optionalProgramList);
            parameters.put("optionalProgram", jrBeanCollectionDataSource);
            parameters.put("hasOptionalPrograms", "true");
        }

        List<String> careerProgramCodes = this.getCareerProgramList(pen);
        if (careerProgramCodes != null && !careerProgramCodes.isEmpty()) {
            String careerPrograms = careerProgramCodes.stream().map(Object::toString).collect(Collectors.joining(", "));
            parameters.put("careerProgramsObj", careerPrograms);
        }

        Date issueDate = getIssueDate();
        if (issueDate != null) {
            parameters.put("issueDateObj", issueDate);
        }

        ca.bc.gov.educ.grad.report.model.school.School schoolObj = adaptSchool(studentInfo, getAccessToken(), false);
        if (schoolObj != null) {
            parameters.put("schoolObj", schoolObj);
        }

        ca.bc.gov.educ.grad.report.model.student.Student studentObj = adaptStudent(personalEducationNumber, studentInfo);
        if (studentObj != null) {
            parameters.put("studentObj", studentObj);
        }

        GraduationStatus graduationStatus = getGraduationStatus(pen);
        if (graduationStatus != null) {
            parameters.put("gradObj", graduationStatus);
        }

        if(StringUtils.isNotBlank(studentInfo.getLogo())) {
            InputStream inputLogo = openImageResource("logo_" + studentInfo.getLogo().toLowerCase(Locale.ROOT) + "_bw.svg");
            parameters.put("orgImage", inputLogo);
        }

        final StudentAchievementReport report = createReport(
                format,
                preview,
                parameters,
                interim,
                gradReqYear
        );

        LOG.exiting(CLASSNAME, methodName);
        return report;
    }

    private String getCreditsUsedForGrad(final Achievement achievement) {
        final List<AchievementResult> results = achievement.getResults();
        int totalCredits = 0;

        for (final AchievementResult achievementResult : results) {
            final String credits = nullSafe(achievementResult.getUsedForGrad());
            totalCredits += parseCredits(credits);
        }

        return "" + totalCredits;
    }

    // FIXME: Pass in GraduationProgramCode enum
    private GraduationData adaptGraduationData(
            final StudentInfo studentInfo,
            final Achievement achievement) {
        final String methodName = "adaptGraduationData(StudentInfo, Achievement, String)";
        final Object[] params = {studentInfo, achievement};
        LOG.entering(CLASSNAME, methodName, params);

        final GraduationData graduationData = new GraduationDataImpl();

        LocalDate gradDate = studentInfo.getGradDate();

        ((GraduationDataImpl) graduationData).setGraduationDate(gradDate);
        ((GraduationDataImpl) graduationData).setHonorsFlag(studentInfo.isHonourFlag());
        ((GraduationDataImpl) graduationData).setDogwoodFlag(studentInfo.isDogwoodFlag());
        ((GraduationDataImpl) graduationData).setProgramNames(studentInfo.getAcademicProgram());
        final String creditsUsedForGrad = getCreditsUsedForGrad(achievement);
        ((GraduationDataImpl) graduationData).setTotalCreditsUsedForGrad(creditsUsedForGrad);

        LOG.exiting(CLASSNAME, methodName);

        return graduationData;
    }

    @Override
    @RolesAllowed({STUDENT_ACHIEVEMENT_REPORT, USER})
    public StudentAchievementReport buildAchievementReport(final ReportFormat format, final boolean interim) throws DomainServiceException, IOException, DataException {
        return createAchievementReport(format, true, interim);
    }

    /**
     * @param results
     * @param code
     * @inheritDoc
     */
    @RolesAllowed({USER, FULFILLMENT_SERVICES_USER})
    @Override
    public List<AchievementResult> sort(
            final List<AchievementResult> results,
            final GraduationProgramCode code) {

        // Perform multiple stable sorts over the achievement results.
        final Comparator<AchievementResult> comparator = createComparator(code);
        Collections.sort(results, comparator);

        // Sort the ungraded courses to the end of the list, which will then
        // be pushed up using the assessment comparator.
        final Comparator<AchievementResult> ungraded = createUngradedComparator();
        Collections.sort(results, ungraded);

        // Sort the ReportCourseType.ASSESSMENT values to the end of the
        // list. This could use a comparator chain.
        final Comparator<AchievementResult> assessments = createAssessmentComparator();
        Collections.sort(results, assessments);

        return results;
    }

    /**
     * The sort order for the courses is as follows:
     * <p>
     * For the 1986 and Adult achievement, the courses are sorted only by course
     * code. For the 2004, 1995, and SCCP achievement, the courses are sorted by
     * course level and then by course name.
     *
     * @param code Program code that influences sort order.
     */
    private Comparator<AchievementResult> createComparator(
            final GraduationProgramCode code) {
        final Comparator<AchievementResult> result;

        switch (code) {
            case PROGRAM_1950:
            case PROGRAM_1986:
                result = createAdultComparator();
                break;

            // 1995, 2004, 2018, etc.
            default:
                result = createRegularComparator();
                break;
        }

        return result;
    }

    /**
     * Returns a comparator that can sort by course code.
     *
     * @return A comparator for sorting by course code.
     */
    private Comparator<AchievementResult> createAdultComparator() {
        return new Comparator<AchievementResult>() {
            @Override
            public int compare(
                    final AchievementResult tr1,
                    final AchievementResult tr2) {
                final String reportCourseType1 = getReportCourseType(tr1);
                final String reportCourseType2 = getReportCourseType(tr2);
                final String code1 = getCourseCode(tr1);
                final String code2 = getCourseCode(tr2);

                return new CompareToBuilder()
                        .append(reportCourseType1, reportCourseType2)
                        .append(code1, code2)
                        .toComparison();
            }
        };
    }

    /**
     * Called for non-Adult reports to provide comparators that can perform
     * stable sub-sorts on the achievement results.
     *
     * @return A list of stable comparators that should be executed in order to
     * sort the achievement results.
     */
    private Comparator<AchievementResult> createRegularComparator() {
        return new Comparator<AchievementResult>() {
            @Override
            public int compare(final AchievementResult tr1, final AchievementResult tr2) {
                final int level1 = getCourseLevel(tr1);
                final int level2 = getCourseLevel(tr2);
                final String name1 = getCourseName(tr1);
                final String name2 = getCourseName(tr2);

                return new CompareToBuilder()
                        .append(level1, level2)
                        .append(name1, name2)
                        .toComparison();
            }
        };
    }

    /**
     * Sorts ungraded to the bottom of the list of achievement results.
     *
     * @return A comparator that can sort ungraded results.
     */
    private Comparator<AchievementResult> createUngradedComparator() {
        return new Comparator<AchievementResult>() {
            @Override
            public int compare(final AchievementResult tr1, final AchievementResult tr2) {
                final int level1 = getCourseLevel(tr1);
                final int level2 = getCourseLevel(tr2);

                final int comparison = new CompareToBuilder()
                        .append(level1, level2)
                        .toComparison();

                return SORT_UNGRADED.equals("" + level1)
                        || SORT_UNGRADED.equals("" + level2)
                        ? comparison
                        : 0;

            }
        };
    }

    /**
     * Used to sort assessments to the bottom of the list of achievement results.
     *
     * @return A comparator that can sort assessment results.
     */
    private Comparator<AchievementResult> createAssessmentComparator() {
        return new Comparator<AchievementResult>() {
            @Override
            public int compare(final AchievementResult tr1, final AchievementResult tr2) {
                final int level1 = getCourseLevel(tr1);
                final int level2 = getCourseLevel(tr2);

                final String reportCourseType1 = getReportCourseType(tr1);
                final String reportCourseType2 = getReportCourseType(tr2);

                final String courseCode1 = getCourseCode(tr1);
                final String courseCode2 = getCourseCode(tr2);

                final int comparison = new CompareToBuilder()
                        .append(level1, level2)
                        .append(reportCourseType1, reportCourseType2)
                        .append(courseCode1, courseCode2)
                        .toComparison();

                return ASSESSMENT.isCode(reportCourseType1)
                        || ASSESSMENT.isCode(reportCourseType2)
                        ? comparison
                        : 0;
            }
        };
    }

    /**
     * Convenience method to obtain a sortable course type.
     *
     * @param tr The achievement result containing report course type that
     *           control sort order.
     * @return The report course type for the given achievement result.
     */
    private String getReportCourseType(final AchievementResult tr) {
        final Course c = tr.getCourse();
        final String reportCourseType = c == null
                ? PROVINCIALLY_EXAMINABLE.getCode()
                : c.getType();

        return reportCourseType;
    }

    /**
     * Convenience method to obtain a sortable course level.
     *
     * @param tr The achievement result containing course levels to be sorted.
     * @return The course level or "99" if the course has no level (and should
     * therefore be sorted to the bottom).
     */
    private int getCourseLevel(final AchievementResult tr) {
        final Course c = tr.getCourse();
        final String cl = c == null ? "" : c.getLevel().trim();
        final String type = c == null ? "" : c.getType();

        final String level = ASSESSMENT.isCode(type)
                ? SORT_ASSESSMENT
                : SORT_UNGRADED;
        final String courseLevel = cl.isEmpty() ? level : cl;
        int result = 0;

        try {
            // Parse "12A" to 12, "11F" to 11, "10" to 10, for sort purposes.
            final NumberFormat nf = getIntegerInstance();
            result = nf.parse(courseLevel).intValue();
        } catch (final Exception ex) {
            LOG.log(Level.SEVERE,
                    "Could not parse course level into integer: " + courseLevel,
                    ex);
        }

        return result;
    }

    /**
     * Convenience method to obtain a sortable course name.
     *
     * @param tr The achievement result containing course names to be sorted.
     * @return The course name, never null, possibly empty.
     */
    private String getCourseName(final AchievementResult tr) {
        final Course c = tr.getCourse();
        final String name = c == null ? "" : c.getName();

        return nullSafe(name);
    }

    /**
     * Convenience method to obtain a sortable course name.
     *
     * @param tr The achievement result containing course names to be sorted.
     * @return The course name, never null, possibly empty.
     */
    private String getCourseCode(final AchievementResult tr) {
        final Course c = tr.getCourse();
        final String code = c == null ? "" : c.getCode();

        return nullSafe(code);
    }

    @Override
    GraduationReport createGraduationReport() {
        throw new NotImplementedException("Method createGraduationReport() not implemented");
    }
}
