/*
 * *********************************************************************
 *  Copyright (c) 2017, Ministry of Education, BC.
 *
 *  All rights reserved.
 *    This information contained herein may not be used in whole
 *    or in part without the express written consent of the
 *    Government of British Columbia, Canada.
 *
 *  Revision Control Information
 *  File:                $Id::                                                 $
 *  Date of Last Commit: $Date::                                               $
 *  Revision Number:     $Rev::                                                $
 *  Last Commit by:      $Author::                                             $
 *
 * ***********************************************************************
 */
package ca.bc.gov.educ.isd.achievement.impl;

import ca.bc.gov.educ.exception.EntityNotFoundException;
import ca.bc.gov.educ.grad.dao.GradToIsdDataConvertBean;
import ca.bc.gov.educ.grad.dto.ReportData;
import ca.bc.gov.educ.isd.achievement.Achievement;
import ca.bc.gov.educ.isd.achievement.AchievementResult;
import ca.bc.gov.educ.isd.achievement.StudentAchievementReport;
import ca.bc.gov.educ.isd.achievement.StudentAchievementService;
import ca.bc.gov.educ.isd.adaptor.dao.impl.TranCourseEntity;
import ca.bc.gov.educ.isd.adaptor.dao.tsw.impl.TswTranNongradEntity;
import ca.bc.gov.educ.isd.adaptor.dao.utils.TRAXThreadDataUtility;
import ca.bc.gov.educ.isd.adaptor.impl.AchievementCourseImpl;
import ca.bc.gov.educ.isd.adaptor.impl.StudentInfoImpl;
import ca.bc.gov.educ.isd.adaptor.impl.TranscriptCourseImpl;
import ca.bc.gov.educ.isd.common.DataException;
import ca.bc.gov.educ.isd.common.DomainServiceException;
import ca.bc.gov.educ.isd.eis.trax.db.*;
import ca.bc.gov.educ.isd.exam.Assessment;
import ca.bc.gov.educ.isd.exam.impl.AssessmentImpl;
import ca.bc.gov.educ.isd.grad.GradProgram;
import ca.bc.gov.educ.isd.grad.GraduationProgramCode;
import ca.bc.gov.educ.isd.grad.NonGradReason;
import ca.bc.gov.educ.isd.grad.impl.GradProgramImpl;
import ca.bc.gov.educ.isd.grad.impl.NonGradReasonImpl;
import ca.bc.gov.educ.isd.reports.*;
import ca.bc.gov.educ.isd.school.School;
import ca.bc.gov.educ.isd.student.PersonalEducationNumber;
import ca.bc.gov.educ.isd.student.Student;
import ca.bc.gov.educ.isd.student.impl.*;
import ca.bc.gov.educ.isd.transcript.Course;
import ca.bc.gov.educ.isd.transcript.GraduationData;
import ca.bc.gov.educ.isd.transcript.ParameterPredicate;
import ca.bc.gov.educ.isd.transcript.impl.CourseImpl;
import ca.bc.gov.educ.isd.transcript.impl.GraduationDataImpl;
import ca.bc.gov.educ.isd.transcript.impl.MarkImpl;
import org.apache.commons.lang3.builder.CompareToBuilder;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Service;

import javax.annotation.security.DeclareRoles;
import javax.annotation.security.RolesAllowed;
import java.io.IOException;
import java.io.Serializable;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;

import static ca.bc.gov.educ.isd.common.Constants.PESC_HST_PREDICATE;
import static ca.bc.gov.educ.isd.common.support.VerifyUtils.nullSafe;
import static ca.bc.gov.educ.isd.common.support.VerifyUtils.trimSafe;
import static ca.bc.gov.educ.isd.common.support.impl.Roles.FULFILLMENT_SERVICES_USER;
import static ca.bc.gov.educ.isd.common.support.impl.Roles.USER;
import static ca.bc.gov.educ.isd.course.ReportCourseType.ASSESSMENT;
import static ca.bc.gov.educ.isd.course.ReportCourseType.PROVINCIALLY_EXAMINABLE;
import static ca.bc.gov.educ.isd.grad.GraduationProgramCode.PROGRAM_SCCP;
import static ca.bc.gov.educ.isd.reports.ReportFormat.PDF;
import static ca.bc.gov.educ.isd.reports.ReportFormat.XML;
import static ca.bc.gov.educ.isd.transcript.impl.RequirementNames.getName;
import static ca.bc.gov.educ.isd.transcript.impl.constants.Roles.STUDENT_TRANSCRIPT_REPORT;
import static java.lang.Integer.parseInt;
import static java.text.NumberFormat.getIntegerInstance;
import static org.apache.commons.lang3.ArrayUtils.isEmpty;

/**
 * The achievement service is an implementation component of the broader
 * Achievement Services group. As part of the mid-tier service layer the
 * buildReport method called by the GUI (browser) to display the unofficial
 * achievement of grades. The display is a rendered report generated by the
 * report service populated with data from the TRAX adaptor for the current user
 * as determined by the student demographics service.
 * <p>
 * This service integrates with the Student Demographics, the TRAX adaptor, and
 * the Reporting Service.
 * </p>
 *
 * The security roles required to build a achievement report are:
 * <ol>
 * <li>XS_REPORT</li>
 * <li>TRAX_READ</li>
 * <li>SXR_READ</li>
 * <li>SXR_SEARCH</li>
 * <li>USER_REPORTS_EXPORT</li>
 * <li>USER_REPORTS_TRANSCRIPT</li>
 * <li>USER_PROFILE_SEARCH</li>
 * <li>USER_PROFILE_READ</li>
 * <li>USER</li>
 * </ol>
 *
 * @author CGI Information Management Consultants Inc.
 */
@Service
@DeclareRoles({STUDENT_TRANSCRIPT_REPORT, USER, FULFILLMENT_SERVICES_USER})
public class StudentAchievementServiceImpl implements StudentAchievementService, Serializable {

    private static final long serialVersionUID = 5L;

    private static final String CLASSNAME = StudentAchievementServiceImpl.class.getName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    /**
     * Sort order for ungraded courses (to bottom, above assessments).
     */
    private static final String SORT_UNGRADED = "99";

    /**
     * Sort order for assessments (to bottom, below ungraded).
     */
    private static final String SORT_ASSESSMENT = "100";

    private final String FORMAT_COURSE_CODE = "%-5s";
    private final String FORMAT_COURSE_LEVEL = "%-3s";

    @Autowired
    private ReportService reportService;

    @Autowired
    GradToIsdDataConvertBean gradtoIsdDataConvertBean;

    /**
     * Creates the student's official achievement as a PDF (no other formats are
     * allowed for official achievements).
     *
     * @return A filled achievement report suitable for sending to a PSI.
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    @Override
    @RolesAllowed({STUDENT_TRANSCRIPT_REPORT, USER})
    public StudentAchievementReport buildOfficialAchievementReport()
            throws DomainServiceException, IOException, DataException {
        return createAchievementReport(PDF, false, false);
    }

    /**
     * Builds an unofficial achievement report.
     *
     * @param format PDF, HTML, etc.
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    @Override
    @RolesAllowed({STUDENT_TRANSCRIPT_REPORT, USER})
    public StudentAchievementReport buildAchievementReport(
            final ReportFormat format)
            throws DomainServiceException, IOException, DataException {
        return buildAchievementReport(format, false);
    }

    /**
     * Builds an unofficial achievement report.
     *
     * @param format PDF, HTML, etc.
     * @param pen student identifier.
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    @Override
    @RolesAllowed({FULFILLMENT_SERVICES_USER})
    public StudentAchievementReport buildAchievementReport(
            final ReportFormat format, final PersonalEducationNumber pen, final Parameters parameters, final boolean interim)
            throws DomainServiceException, IOException, DataException {
        return createAchievementReport(format, true, pen, parameters, interim);
    }

    /**
     * Builds an unofficial achievement report asynchronously. Calls
     * <code>createAchievementReport(ReportFormat, true)</code> and returns the
     * result wrapped in an AsyncResult.
     *
     * @param format PDF, HTML, etc.
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    @Override
    @RolesAllowed({STUDENT_TRANSCRIPT_REPORT, USER})
    public Future<StudentAchievementReport> buildAchievementReportAsync(
            final ReportFormat format)
            throws DomainServiceException, IOException, DataException {
        return new AsyncResult<>(createAchievementReport(format, true, false));
    }

    @Override
    @RolesAllowed({STUDENT_TRANSCRIPT_REPORT, USER})
    public Achievement getAchievement() throws DomainServiceException {
        final String _m = "getAchievement()";
        LOG.entering(CLASSNAME, _m);

        final String pen = getStudentPENId();
        final Achievement achievement = getAchievement(pen, false);

        LOG.exiting(CLASSNAME, _m);
        return achievement;
    }

    @Override
    @RolesAllowed({STUDENT_TRANSCRIPT_REPORT, USER})
    public Achievement getAchievement(
            final String pen,
            final boolean interim) throws DomainServiceException {
        final String _m = "getAchievement(String)";
        LOG.entering(CLASSNAME, _m);

        final List<AchievementCourse> achievementCourses = getAchievementCourseList(pen, interim);
        final StudentInfo studentInfo = getStudentInfo(pen);
        final String programCode = studentInfo.getGradProgram();
        final GradProgram program = createGradProgram(programCode);
        final Date reportDate = studentInfo.getReportDate();

        final Achievement achievement = adapt(
                program.getCode(),
                achievementCourses,
                reportDate,
                interim
        );

        LOG.exiting(CLASSNAME, _m);
        return achievement;
    }

    @RolesAllowed({STUDENT_TRANSCRIPT_REPORT, USER})
    public Assessment getAssessment(
            final String pen) throws DomainServiceException {
        final String _m = "getAssessment(String)";
        LOG.entering(CLASSNAME, _m);

        final List<AssessmentResult> assessmentResults = getAssessmentResultList(pen);
        final StudentInfo studentInfo = getStudentInfo(pen);
        final String programCode = studentInfo.getGradProgram();
        final GradProgram program = createGradProgram(programCode);
        final Date reportDate = studentInfo.getReportDate();

        final Assessment assessment = adapt(
                assessmentResults,
                reportDate
        );

        LOG.exiting(CLASSNAME, _m);
        return assessment;
    }

    @Override
    @RolesAllowed({STUDENT_TRANSCRIPT_REPORT, USER})
    public Achievement getAchievementInformation(final String pen) throws DomainServiceException {
        final String _m = "getAchievementInformation(String)";
        LOG.entering(CLASSNAME, _m);

        Integer numberAchievementCourses = 0;
        try {
            ReportData reportData = TRAXThreadDataUtility.getGenerateReportData();

            if (reportData == null) {
                EntityNotFoundException dse = new EntityNotFoundException(
                        null,
                        "Report Data not exists for the current report generation");
                LOG.throwing(CLASSNAME, _m, dse);
                throw dse;
            }

            final List<TranscriptCourse> courses = gradtoIsdDataConvertBean.getTranscriptCources(reportData);
            numberAchievementCourses = courses.size();

        } catch (Exception ex) {
            String msg = "Failed to access TRAX achievement course data for student with PEN: ".concat(pen);
            final DataException dex = new DataException(null, null, msg, ex);
            LOG.throwing(CLASSNAME, _m, dex);
            throw dex;
        }

        final StudentInfo studentInfo = getStudentInfo(pen);
        final Date issueDate = studentInfo.getReportDate();

        boolean isEmpty = (numberAchievementCourses == 0);
        final Achievement achievement = new AchievementInformationImpl(issueDate, isEmpty);

        LOG.exiting(CLASSNAME, _m);
        return achievement;
    }

    private GradProgram createGradProgram(String code) {
        return new GradProgramImpl(GraduationProgramCode.valueFrom(code));
    }

    /**
     * Creates a report in a specific format, either official or unofficial,
     * depending on the preview value.
     *
     * @param format
     * @param preview Set to false to create an unofficial achievement
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    private StudentAchievementReport createAchievementReport(
            final ReportFormat format,
            final boolean preview, final boolean interim)
            throws DomainServiceException, IOException, DataException {
        final String _m = "createAchievement(ReportFormat, boolean)";
        LOG.entering(CLASSNAME, _m);

        final PersonalEducationNumber pen = getStudentPEN();
        LOG.log(Level.FINE, "Retrieved studentInfo for pen: {0}.", pen.getValue());

        final StudentAchievementReport report = getStudentAchievementReport(
                pen, format, preview, null, interim
        );
        LOG.exiting(CLASSNAME, _m);
        return report;
    }

    /**
     * Creates a report in a specific format, either official or unofficial,
     * depending on the preview value. Takes the PEN to generate the desired
     * report.
     *
     * @param format
     * @param preview Set to false to create an unofficial achievement
     * @return
     * @throws DomainServiceException
     * @throws IOException
     * @throws DataException
     */
    private StudentAchievementReport createAchievementReport(
            final ReportFormat format,
            final boolean preview, final PersonalEducationNumber pen, final Parameters parameters, final boolean interim)
            throws DomainServiceException, IOException, DataException {
        final String _m = "createAchievement(ReportFormat, boolean)";
        LOG.entering(CLASSNAME, _m);
        LOG.log(Level.FINE, "Retrieved achievement for pen: {0}.", pen.getValue());

        final StudentAchievementReport report = getStudentAchievementReport(pen, format, preview, parameters, interim);
        LOG.log(Level.INFO, "Created StudentAchievementReport for pen: {0}.", pen.getValue());

        LOG.exiting(CLASSNAME, _m);
        return report;
    }

    private String getStudentPENId() throws DomainServiceException {
        final String _m = "getStudentPENId()";
        LOG.entering(CLASSNAME, _m);

        final PersonalEducationNumber pen = getStudentPEN();
        final String result = pen.getValue();

        LOG.exiting(CLASSNAME, _m);
        return result;
    }

    private PersonalEducationNumber getStudentPEN() throws DomainServiceException {
        final String _m = "getStudentPEN()";
        LOG.entering(CLASSNAME, _m);

        ReportData reportData = TRAXThreadDataUtility.getGenerateReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    null,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, _m, dse);
            throw dse;
        }

        PersonalEducationNumberSimple pen = new PersonalEducationNumberSimple();
        pen.setPen(reportData.getStudent().getPen().getValue());

        LOG.log(Level.FINE, "Confirmed the user is a student and retrieved the PEN: {0}.", pen);
        LOG.exiting(CLASSNAME, _m);
        return pen;
    }

    /**
     * Read the static student data from TRAX which is needed for the achievement
     * service.
     *
     * @param pen
     *
     * @return
     */
    private StudentInfo getStudentInfo(final String pen) throws DataException, DomainServiceException {
        final String _m = "getStudentInfo(String)";
        LOG.entering(CLASSNAME, _m);

        final StudentInfo studentInfo;

        try {
            ReportData reportData = TRAXThreadDataUtility.getGenerateReportData();

            if (reportData == null) {
                EntityNotFoundException dse = new EntityNotFoundException(
                        null,
                        "Report Data not exists for the current report generation");
                LOG.throwing(CLASSNAME, _m, dse);
                throw dse;
            }

            StudentInfoImpl student = (StudentInfoImpl) gradtoIsdDataConvertBean.getStudentInfo(reportData);
            final List<TswTranNongradEntity> reasonList = gradtoIsdDataConvertBean.getTswTranNongradEntity(reportData);
            final HashMap<String, String> reasons = new HashMap<>();
            for (final TswTranNongradEntity reason : reasonList) {
                final String code = reason.getNonGradCode().trim();
                final String text = reason.getNonGradDesc().trim();
                reasons.put(code, text);
            }
            student.setNonGradReasons(reasons);
            studentInfo = student;

            LOG.log(Level.FINER,
                    "Retrieved student info from TRAX for PEN: {0}", pen);

            if (studentInfo == null) {
                final String msg = "Failed to find achievement results in TRAX for PEN: ".concat(pen);
                final DomainServiceException dse = new DomainServiceException(null, msg);
                LOG.throwing(CLASSNAME, _m, dse);
                throw dse;
            } else {
                LOG.log(Level.FINEST, "Retrieved student from achievement:");
                LOG.log(Level.FINEST, "{0} {1} {2}",
                        new Object[]{studentInfo.getPen(), studentInfo.getFirstName(), studentInfo.getLastName()});
            }

        } catch (Exception ex) {
            String msg = "Failed to access TRAX achievement data for student with PEN: ".concat(pen);
            final DataException dex = new DataException(null, null, msg, ex);
            LOG.throwing(CLASSNAME, _m, dex);
            throw dex;
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, _m);
        return studentInfo;
    }

    /**
     * Read the static student data (demographics) from TRAX which is needed for
     * the achievement service.
     *
     * @param pen
     *
     * @return
     */
    private StudentDemographic getStudentDemog(final String pen) throws DataException, DomainServiceException {
        final String _m = "getStudentDemog(String)";
        LOG.entering(CLASSNAME, _m);

        final StudentDemographic studentDemographic;

        ReportData reportData = TRAXThreadDataUtility.getGenerateReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    null,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, _m, dse);
            throw dse;
        }

        try {
            studentDemographic = gradtoIsdDataConvertBean.getSingleStudentDemog(reportData);

            LOG.log(Level.FINER,
                    "Retrieved student demographic from TRAX for PEN: {0}", pen);

            if (studentDemographic == null) {
                final String msg = "Failed to find demographic data in TRAX for PEN: ".concat(pen);
                final DomainServiceException dse = new DomainServiceException(null, msg);
                LOG.throwing(CLASSNAME, _m, dse);
                throw dse;
            } else {
                LOG.log(Level.FINEST, "Retrieved student demographic data:");
                LOG.log(Level.FINEST, "{0} {1} {2}",
                        new Object[]{studentDemographic.getPen(), studentDemographic.getFirstName(), studentDemographic.getLastName()});
            }

        } catch (Exception ex) {
            String msg = "Failed to access TRAX achievement data for student with PEN: ".concat(pen);
            final DataException dex = new DataException(null, null, msg, ex);
            LOG.throwing(CLASSNAME, _m, dex);
            throw dex;
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, _m);
        return studentDemographic;
    }

    /**
     * Read the collection of achievement courses from the TRAX Adaptor which is
     * required for the achievement service.
     *
     * @param pen Student identifier.
     *
     * @return
     */
    private List<AchievementCourse> getAchievementCourseList(
            final String pen, final boolean interim)
            throws DataException, DomainServiceException {
        final String m_ = "getAchievementCourseList(String, boolean)";
        LOG.entering(CLASSNAME, m_);

        final List<AchievementCourse> results;

        try {
            ReportData reportData = TRAXThreadDataUtility.getGenerateReportData();

            if (reportData == null) {
                EntityNotFoundException dse = new EntityNotFoundException(
                        null,
                        "Report Data not exists for the current report generation");
                LOG.throwing(CLASSNAME, m_, dse);
                throw dse;
            }
            ArrayList retList = new ArrayList<>();
            final List<TranscriptCourse> courses = gradtoIsdDataConvertBean.getTranscriptCources(reportData);
            for (final TranscriptCourse course : courses) {
                AchievementCourseImpl c = new AchievementCourseImpl();
                BeanUtils.copyProperties(course, c);
                retList.add(c);
                addExtendedCourseInfo((TranscriptCourseImpl)course);
            }

            results = retList;

            LOG.log(Level.INFO,
                    "Retrieved the collection of exam results from TRAX for PEN: {0} INTERIM: {1}",
                    new Object[]{pen, interim});

            if (results != null && !results.isEmpty()) {
                LOG.log(Level.INFO,
                        "Total courses {0} retrieved  for PEN: {1}",
                        new Object[]{results.size(), pen});
                LOG.log(Level.FINEST, "Retrieved student achievement course results:");
                for (AchievementCourse result : results) {
                    LOG.log(Level.FINEST, "{0} {1}",
                            new Object[]{result.getCourseName(), result.getFinalLetterGrade()});
                }
            }
        } catch (final Exception ex) {
            String msg = "Failed to access TRAX achievement course data for student with PEN: ".concat(pen);
            final DataException dex = new DataException(null, null, msg, ex);
            LOG.throwing(CLASSNAME, m_, dex);
            throw dex;
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, m_);
        return results;
    }

    /**
     * Additional information is required to populate all the course fields,
     * found in other entities. Using the provided course information get the
     * entity search parameters, padded out to the correct length as the course
     * attributes are all trimmed. Search for the additional information and
     * populate the course record if that information exists.
     *
     * @param course
     */
    private void addExtendedCourseInfo(final TranscriptCourseImpl course) {
        final String _m = "addExtendedCourseInfo(TranscriptCourseImpl)";
        LOG.entering(CLASSNAME, _m);

        final String pen = course.getPen();
        final String courseCode = course.getCourseCode();
        final String paddedCourseCode = String.format(FORMAT_COURSE_CODE, courseCode);
        final String courseLevel = course.getCourseLevel();
        final String paddedCourseLevel = String.format(FORMAT_COURSE_LEVEL, courseLevel);
        final String sessionDate = course.getSessionDate();

        final String usedForGrad;

        if (course.isExaminable()) {
            usedForGrad = getPEUsedForGrad(pen, paddedCourseCode, paddedCourseLevel, sessionDate, course);
        } else {
            usedForGrad = getSXRelatedUsedForGrad(pen, paddedCourseCode, paddedCourseLevel, sessionDate, course);
        }

        // Converts the character to a string, then trims to remove spaces.
        course.setUsedForGrad(trimSafe(usedForGrad));

        LOG.exiting(CLASSNAME, _m);
    }

    /**
     * Search the <code>StsTranCourseEntity</code> looking for the matching
     * student number, course code, course level and course session as the
     * provided course. This information is used to determine if there is a
     * <code>Used_For_Grad</code> value associated with this course.
     *
     * @param pen
     * @param paddedCourseCode
     * @param paddedCourseLevel
     * @param session
     * @return Used_For_Grad Character if one is found
     */
    private String getPEUsedForGrad(
            final String pen,
            final String paddedCourseCode,
            final String paddedCourseLevel,
            final String session,
            final TranscriptCourseImpl course) {
        final String _m = "getPEUsedForGrad(String, String, String, String)";
        LOG.entering(CLASSNAME, _m);

        String usedForGraduation = " ";

        ReportData reportData = TRAXThreadDataUtility.getGenerateReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    null,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, _m, dse);
            throw dse;
        }

        try {
            final TranCourseEntity stsTransCourseEntity = (TranCourseEntity) gradtoIsdDataConvertBean.getTranCourse(reportData, course);
            final String usedForGraduationVal = stsTransCourseEntity.getUsedForGrad();

            usedForGraduation = (usedForGraduationVal == null ? " " : usedForGraduationVal);

        } catch (final Exception ex) {
            // Do nothing for a student without exam entities.
        }

        LOG.exiting(CLASSNAME, _m);
        return usedForGraduation;
    }

    /**
     * Search the <code>StSTranCourseEntity</code> looking for the matching
     * student number, course code, course level and course session as the
     * provided course.
     *
     * This information is used to determine if there is a
     * <code>Used_For_Grad</code> value associated with this course. It is also
     * used to set the related course code and related course level for this
     * course if a matching record is found.
     *
     * @param pen The students Personal Education Number
     * @param paddedCourseCode The course short code
     * @param paddedCourseLevel The corse grade level
     * @param session Course session the student attended
     * @param course Transcript Course object to be populated with related
     * course and level data.
     * @return Used_For_Grad Character if one is found
     */
    private String getSXRelatedUsedForGrad(
            final String pen,
            final String paddedCourseCode,
            final String paddedCourseLevel,
            final String session,
            final TranscriptCourseImpl course) {
        final String _m = "getSXRelatedUsedForGrad(String, String, String, String, TranscriptCourseImpl)";
        LOG.entering(CLASSNAME, _m);

        String usedForGraduation = " ";

        ReportData reportData = TRAXThreadDataUtility.getGenerateReportData();

        if (reportData == null) {
            EntityNotFoundException dse = new EntityNotFoundException(
                    null,
                    "Report Data not exists for the current report generation");
            LOG.throwing(CLASSNAME, _m, dse);
            throw dse;
        }

        try {

            final TranCourseEntity tranCourseEntity = (TranCourseEntity) gradtoIsdDataConvertBean.getTranCourse(reportData, course);

            final String relatedCourse = tranCourseEntity.getRelatedCrse();
            final String relatedCourseSanitized = trimSafe(relatedCourse);
            course.setRelatedCourse(relatedCourseSanitized);

            final String relatedLevel = tranCourseEntity.getRelatedLevel();
            final String relatedLevelSanitized = trimSafe(relatedLevel);
            course.setRelatedLevel(relatedLevelSanitized);

            final String usedForGraduationValue = tranCourseEntity.getUsedForGrad();
            usedForGraduation = (usedForGraduationValue == null ? " " : usedForGraduationValue);
        } catch (final Exception ex) {
            // this indicates a data issue.  Unable to determine correct record so leave TranscriptCourseImpl with default empty attributes.
            LOG.log(Level.WARNING, "Found multiple StudXcrseEntities matching {0},{1},{2},{3}", new Object[]{pen, paddedCourseCode, paddedCourseLevel, session});
        }

        LOG.exiting(CLASSNAME, _m);
        return usedForGraduation;
    }

    /**
     * Read the collection of achievement courses from the TRAX Adaptor which is
     * required for the achievement service.
     *
     * @param pen Student identifier.
     *
     * @return
     */
    private List<AssessmentResult> getAssessmentResultList(
            final String pen)
            throws DataException, DomainServiceException {
        final String m_ = "getAssessmentList(String, boolean)";
        LOG.entering(CLASSNAME, m_);

        final List<AssessmentResult> results;

        try {
            LOG.log(Level.INFO,
                    "Retrieved the collection of exam results from TRAX for PEN: {0}",
                    new Object[]{pen});

            ReportData reportData = TRAXThreadDataUtility.getGenerateReportData();

            if (reportData == null) {
                EntityNotFoundException dse = new EntityNotFoundException(
                        null,
                        "Report Data not exists for the current report generation");
                LOG.throwing(CLASSNAME, m_, dse);
                throw dse;
            }

            List<NumAssessmentResult> resultsList = gradtoIsdDataConvertBean.getAssessmentCourses(reportData);
            results = new ArrayList<>();
            for(AssessmentResult course: resultsList) {
                results.add(course);
            }

            if (results != null && !results.isEmpty()) {
                LOG.log(Level.INFO,
                        "Total courses {0} retrieved  for PEN: {1}",
                        new Object[]{results.size(), pen});
                LOG.log(Level.FINEST, "Retrieved student achievement course results:");
                for (AssessmentResult result : results) {
                    LOG.log(Level.FINEST, "{0} {1}",
                            new Object[]{result.getAssessmentCode(), result.getAssessmentProficiencyScore()});
                }
            }
        } catch (final Exception ex) {
            String msg = "Failed to access TRAX achievement course data for student with PEN: ".concat(pen);
            final DataException dex = new DataException(null, null, msg, ex);
            LOG.throwing(CLASSNAME, m_, dex);
            throw dex;
        }

        LOG.log(Level.FINE, "Completed call to TRAX.");
        LOG.exiting(CLASSNAME, m_);
        return results;
    }

    /**
     * Adapt the TRAX data from the data value object into a Student object.
     *
     * @param pen
     * @param traxStudentInfo
     */
    private Student adaptStudent(
            final PersonalEducationNumber pen,
            final StudentInfo traxStudentInfo) {

        final String _m = "adaptStudent(PersonalEducationNumber, StudentInfo)";
        final Object[] params = {pen, traxStudentInfo};
        LOG.entering(CLASSNAME, _m, params);

        final StudentImpl student = new StudentImpl();
        student.setPen(pen);
        student.setFirstName(traxStudentInfo.getFirstName());
        student.setMiddleName(traxStudentInfo.getMiddleName());
        student.setLastName(traxStudentInfo.getLastName());
        student.setBirthdate(traxStudentInfo.getBirthDate());
        student.setGrade(traxStudentInfo.getGrade());

        final PostalAddressImpl address = new PostalAddressImpl();
        address.setStreetLine1(traxStudentInfo.getStudentAddress1());
        address.setStreetLine2(traxStudentInfo.getStudentAddress2());
        address.setCity(traxStudentInfo.getStudentCity());
        address.setCode(traxStudentInfo.getStudentPostalCode());
        address.setRegion(traxStudentInfo.getStudentProv());
        address.setCountry(traxStudentInfo.getCountryCode());
        student.setCurrentMailingAddress(address);

        LOG.exiting(CLASSNAME, _m);
        return student;
    }

    /**
     * Adapt the TRAX data from the data value object into a School object.
     *
     * @param traxStudent
     */
    private School adaptSchool(final StudentInfo traxStudent) {
        final String m_ = "adaptSchool(StudentInfo)";
        LOG.entering(CLASSNAME, m_, traxStudent);

        final SchoolImpl school = new SchoolImpl();
        school.setMincode(traxStudent.getMincode());
        school.setName(traxStudent.getSchoolName());
        school.setTypeIndicator(traxStudent.getSchoolTypeIndicator());
        school.setTypeBanner(traxStudent.getSchoolTypeBanner());

        final CanadianPostalAddressImpl address = new CanadianPostalAddressImpl();
        address.setStreet1(traxStudent.getSchoolStreet());
        address.setStreet2(traxStudent.getSchoolStreet2());
        address.setCity(traxStudent.getSchoolCity());
        address.setPostalCode(traxStudent.getSchoolPostalCode());
        address.setProvince(traxStudent.getSchoolProv());
        school.setAddress(address);

        LOG.exiting(CLASSNAME, m_);
        return school;
    }

    /**
     * Adapt the TRAX data from the collection of data value objects into a
     * Achievement object.
     *
     * @param code The graduation program code that influences sort order.
     * @param traxAchievementCourses
     * @param issueDate
     */
    private Achievement adapt(
            final GraduationProgramCode code,
            final List<AchievementCourse> traxAchievementCourses,
            final Date issueDate,
            final boolean interim) {
        final String m_ = "adapt(GraduationProgramCode, List<AchievementCourse>, Date, boolean)";
        LOG.entering(CLASSNAME, m_, traxAchievementCourses);

        final List<AchievementResult> achievementResults = adapt(
                code, traxAchievementCourses);

        final AchievementImpl achievement = new AchievementImpl();
        achievement.setIssueDate(issueDate);
        achievement.setResults(achievementResults);
        achievement.setInterim(interim);

        LOG.exiting(CLASSNAME, m_);
        return achievement;
    }

    private Assessment adapt(
            final List<AssessmentResult> assessmentResults,
            final Date issueDate) {
        final String m_ = "adapt(GraduationProgramCode, List<AchievementCourse>, Date, boolean)";
        LOG.entering(CLASSNAME, m_, assessmentResults);

        final List<ca.bc.gov.educ.isd.exam.AssessmentResult> assessmentResultList = adapt(assessmentResults);

        final AssessmentImpl assessment = new AssessmentImpl();
        assessment.setResults(assessmentResultList);

        LOG.exiting(CLASSNAME, m_);
        return assessment;
    }

    /**
     * Adapt the TRAX data from the collection of data value objects into a
     * Achievement object.
     *
     * @param programCode The graduation program code that influences sort
     * order.
     * @param traxAchievementCourses
     */
    private List<AchievementResult> adapt(
            final GraduationProgramCode programCode,
            final List<AchievementCourse> traxAchievementCourses) {
        final String m_ = "adapt(GraduationProgramCode, List<AchievementCourse>)";
        LOG.entering(CLASSNAME, m_, traxAchievementCourses);

        List<AchievementResult> achievementResults = Collections.emptyList();

        if (traxAchievementCourses != null) {
            final int size = traxAchievementCourses.size();
            achievementResults = new ArrayList<>(size);

            for (final AchievementCourse traxCourse : traxAchievementCourses) {
                final String courseType = traxCourse.getCourseType();

                final String eq = traxCourse.getEquivalency();
                final String req = traxCourse.getRequirement();
                final String ufg = traxCourse.getUsedForGrad();
                final String reqName = getName(req, programCode.toString());
                final AchievementResultImpl tResult = new AchievementResultImpl(
                        req, eq, ufg, reqName);

                final String courseName = traxCourse.getCourseName();
                final String courseCode = traxCourse.getCourseCode();
                final String courseLevel = traxCourse.getCourseLevel();
                final String traxCredits = traxCourse.getCredits();
                final String relatedCourse = traxCourse.getRelatedCourse();
                final String relatedLevel = traxCourse.getRelatedLevel();

                final String sessionDate = traxCourse.getSessionDate();
                final CourseImpl course = new CourseImpl(
                        courseName, courseCode,
                        courseLevel, traxCredits,
                        sessionDate, courseType,
                        relatedCourse, relatedLevel);

                tResult.setCourse(course);

                final String schoolPct = traxCourse.getSchoolPercent();
                final String examPct = traxCourse.getExamPercent();
                String finalPct = traxCourse.getFinalPercent();
                final String finalLetterGrade = traxCourse.getFinalLetterGrade();
                final String interimPct = traxCourse.getInterimMark();
                final String interimLetterGrade = traxCourse.getInterimLetterGrade();

                final MarkImpl mark = new MarkImpl();
                mark.setSchoolPercent(schoolPct);
                mark.setExamPercent(examPct);

                // Marks should only contain interim OR final
                if ("0".equals(finalPct)) {
                    finalPct = "";
                }

                if (finalPct.isEmpty() && finalLetterGrade.isEmpty()) {
                    mark.setInterimLetterGrade(interimLetterGrade);
                    mark.setInterimPercent(interimPct);
                } else {
                    mark.setFinalLetterGrade(finalLetterGrade);
                    mark.setFinalPercent(finalPct);
                }

                tResult.setMark(mark);
                achievementResults.add(tResult);
            }

            sort(achievementResults, programCode);
        }

        LOG.exiting(CLASSNAME, m_);
        return achievementResults;
    }

    private List<ca.bc.gov.educ.isd.exam.AssessmentResult> adapt(
            final List<AssessmentResult> traxAssessmentResults) {
        final String m_ = "adapt(List<AssessmentResult>)";
        LOG.entering(CLASSNAME, m_, traxAssessmentResults);

        List<ca.bc.gov.educ.isd.exam.AssessmentResult> assessmentResults = Collections.emptyList();

        LOG.exiting(CLASSNAME, m_);
        return assessmentResults;
    }

    /**
     * Convert non-graduation reasons from a TRAX map to an STs list.
     *
     * @param traxStudent The student instance that has non-grad reasons to
     * convert.
     *
     * @return The map of non-grad reasons converted from a map to a list of
     * NonGradReasons instances.
     */
    private List<NonGradReason> adaptReasons(final StudentInfo traxStudent) {
        final String _m = "adaptReasons(StudentInfo)";
        LOG.entering(CLASSNAME, _m);

        final Map<String, String> traxReasons = traxStudent.getNonGradReasons();
        final List<NonGradReason> reasons = new ArrayList<>();

        for (Map.Entry<String, String> entry : traxReasons.entrySet()) {
            final String key = entry.getKey();
            final String value = entry.getValue();
            NonGradReasonImpl r = new NonGradReasonImpl();
            r.setCode(key);
            r.setDescription(value);
            reasons.add(r);
        }

        LOG.exiting(CLASSNAME, _m);
        return reasons;
    }

    /**
     * Create an unofficial achievement of grades report.
     *
     * @param reportFormat
     * @param preview
     * @param student
     * @param school
     * @param logo
     * @param achievement
     * @param program
     * @param nonGradReasons
     * @param gradMessage
     *
     * @return
     *
     * @throws DomainServiceException
     */
    private synchronized StudentAchievementReport createReport(
            final ReportFormat reportFormat,
            final boolean preview,
            final Student student,
            final School school,
            final String logo,
            final Achievement achievement,
            final Assessment assessment,
            final GradProgram program,
            final List<NonGradReason> nonGradReasons,
            final String gradMessage,
            final Date updateDt,
            final Parameters parameters,
            final GraduationData graduationData) throws DomainServiceException, IOException {
        final String _m = "createReport(...)";
        LOG.entering(CLASSNAME, _m);

        final AchievementReport report = reportService.createAchievementReport();

        if (parameters != null) {
            report.setParameters(parameters);
        }

        // Indicate official/unofficial
        report.setPreview(preview);

        report.setStudent(student);
        report.setSchool(school, logo);
        report.setGraduationProgram(program);
        report.setAchievement(achievement);
        report.setAssessment(assessment);
        report.setGraduationStatus(nonGradReasons, gradMessage);
        report.setReportDate(updateDt);
        report.setFormat(reportFormat);

        final boolean interim = ((AchievementImpl) achievement).getInterim();
        report.setInterim(interim);

        if (reportFormat == XML) {
            final ParameterPredicate pp = reportService.createParameterPredicate();
            pp.setKey(PESC_HST_PREDICATE);
            report.setParameterPredicate(pp);
            report.setGraduationData(graduationData);
        }

        final ReportDocument document;

        try {
            ca.bc.gov.educ.isd.reports.data.impl.Student stu = (ca.bc.gov.educ.isd.reports.data.impl.Student)report.getDataSource();

            System.out.println("student.pen = " + stu.getPEN());
            System.out.println("student.firstName = " + stu.getFirstName());
            System.out.println("student.lastName = " + stu.getLastName());
            System.out.println("student.middleNames = " + stu.getMiddleNames());
            System.out.println("student.birthdate = " + new SimpleDateFormat( "yy/MM/dd" ).format(stu.getBirthdate()));
            System.out.println("student.graduationProgram.description = " + stu.getGraduationProgram().getDescription());
            System.out.println("report date = " + new SimpleDateFormat( "d-MMM-yyyy").format( new Date()).toUpperCase());
            System.out.println("student.school.name = " + stu.getSchool().getName().toUpperCase());
            System.out.println("student.school.districtOrganisation.name = " + stu.getSchool().getDistrictOrganisation().getName());
            System.out.println("student.school.districtOrganisation.logoCode = " + stu.getSchool().getDistrictOrganisation().getLogoCode());
            System.out.println("student.school.address.formattedStreet = " + stu.getSchool().getAddress().getFormattedStreet());
            System.out.println("student.school.address.city = " + stu.getSchool().getAddress().getCity() + stu.getSchool().getAddress().getRegion());
            System.out.println("student.school.address.region = " + stu.getSchool().getAddress().getRegion());
            System.out.println("student.school.address.postalCode = " + stu.getSchool().getAddress().getPostalCode());
            System.out.println("student.school.typeBanner = " + stu.getSchool().getTypeBanner().toUpperCase());
            System.out.println("student.school.ministryCode = " + stu.getSchool().getMinistryCode().toUpperCase());
            System.out.println("student.achievementResults = " + stu.getAchievementResults().size());
            System.out.println("student.assessments = " + stu.getAssessments().size());
            System.out.println("student.provinciallyExaminableCourses = " + stu.getProvinciallyExaminableCourses().size());
            System.out.println("student.nonProvinciallyExaminableCourses = " + stu.getNonProvinciallyExaminableCourses().size());
            System.out.println("student.status.graduationMessage = " + stu.getStatus().getGraduationMessage());
            System.out.println("student.status.graduated = " + stu.getStatus().getGraduated());

            document = reportService.export(report);
        } catch (final Exception ex) {
            final String msg = "Failed to create report.";
            LOG.log(Level.SEVERE, msg, ex);
            final DomainServiceException dse = new DomainServiceException(msg, ex);
            LOG.throwing(CLASSNAME, _m, dse);
            throw dse;
        }
        LOG.log(Level.FINE, "Created document {0} for student {1}.", new Object[]{document, student.getPen()});

        final String filename = report.getFilename();
        final byte[] content = document.asBytes();

        if (isEmpty(content)) {
            final String msg = "The generated report output is empty.";
            DomainServiceException dse = new DomainServiceException(msg);
            LOG.throwing(CLASSNAME, _m, dse);
            throw dse;
        }

        final StudentAchievementReport achievementReport = new StudentAchievementReportImpl(
                content, reportFormat, filename, "Achievement"
        );
        LOG.log(Level.FINE, "Created StudentAchievementReport {0} for student {1}.", new Object[]{achievementReport, student.getPen()});

        LOG.exiting(CLASSNAME, _m);
        return achievementReport;
    }

    @Override
    @RolesAllowed({FULFILLMENT_SERVICES_USER})
    public Parameters createParameters() {
        final String _m = "createParameters()";
        LOG.entering(CLASSNAME, _m);

        Parameters parameters = reportService.createParameters();

        LOG.exiting(CLASSNAME, _m);
        return parameters;
    }

    private StudentAchievementReport getStudentAchievementReport(
            final PersonalEducationNumber personalEducationNumber,
            final ReportFormat format,
            final boolean preview,
            final Parameters parameters,
            final boolean interim) throws DomainServiceException, IOException {
        final String _m = "getStudentAchievementReport(String, ReportFormat, boolean, Parameters, boolean)";
        LOG.entering(CLASSNAME, _m);
        final String pen = personalEducationNumber.getValue();
        final StudentInfo studentInfo = getStudentInfo(pen);
        final StudentDemographic studentDemog = getStudentDemog(pen);

        // Adapt TRAX data to other objects for reporting.
        final String programCode = studentInfo.getGradProgram();
        final String logo = studentInfo.getLogo();
        final Achievement achievement = getAchievement(pen, interim);
        final Assessment assessment = getAssessment(pen);

        final Student student = adaptStudent(personalEducationNumber, studentInfo);
        final School school = adaptSchool(studentInfo);

        // FIXME: Replace with GraduationProgramCode enum.
        final GradProgram program = createGradProgram(programCode);
        final GraduationData graduationData = adaptGraduationData(studentInfo, studentDemog, achievement, programCode);

        final String gradMessage = studentInfo.getGradMessage();
        final List<NonGradReason> nonGradReasons = adaptReasons(studentInfo);

        final StudentAchievementReport report = createReport(
                format,
                preview,
                student,
                school,
                logo,
                achievement,
                assessment,
                program,
                nonGradReasons,
                gradMessage,
                achievement.getIssueDate(),
                parameters,
                graduationData
        );

        LOG.exiting(CLASSNAME, _m);
        return report;
    }

    private String getCreditsUsedForGrad(final Achievement achievement) {
        final List<AchievementResult> results = achievement.getResults();
        int totalCredits = 0;

        for (final AchievementResult achievementResult : results) {
            final String credits = nullSafe(achievementResult.getUsedForGrad());
            totalCredits += parseCredits(credits);
        }

        return "" + totalCredits;
    }

    // FIXME: Pass in GraduationProgramCode enum
    private GraduationData adaptGraduationData(
            final StudentInfo studentInfo,
            final StudentDemographic studentDemog,
            final Achievement achievement,
            final String programCode) {
        final String _m = "adaptGraduationData(StudentInfo, StudentDemographic, Achievement, String)";
        final Object[] params = {studentInfo, studentDemog, achievement};
        LOG.entering(CLASSNAME, _m, params);

        final GraduationData graduationData = new GraduationDataImpl();
        final GraduationProgramCode program = GraduationProgramCode.valueFrom(programCode);

        Date gradDate = null;

        if (PROGRAM_SCCP.equals(program)) {
            gradDate = studentDemog.getSccDate();
        } else {
            gradDate = studentDemog.getCertificateDate();
        }

        ((GraduationDataImpl) graduationData).setGraduationDate(gradDate);
        ((GraduationDataImpl) graduationData).setHonorsFlag(studentInfo.isHonourFlag());
        ((GraduationDataImpl) graduationData).setDogwoodFlag(studentInfo.isDogwoodFlag());
        ((GraduationDataImpl) graduationData).setProgramNames(studentInfo.getAcademicProgram());
        final String creditsUsedForGrad = getCreditsUsedForGrad(achievement);
        ((GraduationDataImpl) graduationData).setTotalCreditsUsedForGrad(creditsUsedForGrad);

        LOG.exiting(CLASSNAME, _m);

        return graduationData;
    }

    @Override
    @RolesAllowed({STUDENT_TRANSCRIPT_REPORT, USER})
    public StudentAchievementReport buildAchievementReport(final ReportFormat format, final boolean interim) throws DomainServiceException, IOException, DataException {
        return createAchievementReport(format, true, interim);
    }

    /**
     * Ensure that the student's highest mark for a particular course is used.
     * This will remove any duplicate courses that may be present in favour of
     * the highest marked course.
     *
     * @param results Courses for PEN user which might have duplicated courses
     * @return
     */
    private List<AchievementCourse> filterCourses(final List<AchievementCourse> results) {

        final List<AchievementCourse> resultOfCourses = new ArrayList<>();
        for (final AchievementCourse course : results) {

            if (!resultOfCourses.contains(course)) {
                final AchievementCourse interimCourse
                        = getInterimCourse(course, results);

                if (!(resultOfCourses.contains(interimCourse))) {
                    resultOfCourses.add(interimCourse);
                }
            }
        }

        return resultOfCourses;
    }

    /**
     * If the in progress course is a duplicate of a successfully complete
     * course (i.e. the course already appears on the student's achievement with
     * a passing final mark), the in progress course replaces the successfully
     * completed occurrence of the course if and only if the interim percent is
     * greater than the final percent on the successfully completed occurrence
     * of the course. If the interim percent is blank it should not replace the
     * successfully completed occurrence of the course.
     */
    private AchievementCourse getInterimCourse(
            AchievementCourse course,
            final List<AchievementCourse> results) {
        //Check for dulicate courses
        for (final AchievementCourse compareCourse : results) {
            //Check and compare two courses for duplication and if required
            //replace course based on requirement.
            if (course.courseEquals(compareCourse)
                    && course.compareCourse(compareCourse)) {
                course = compareCourse;
            }
        }
        return course;

    }

    /**
     * The number of credits can be a pure numeric value or adorned with extra
     * characters (e.g., 2, 2p, (4)). This parses the numeric value regardless
     * of whether there are non-numeric characters present.
     *
     * @param credits The number of credits to parse.
     * @return The parsed value, or 0 if there were no digits present.
     */
    private int parseCredits(final String credits) {
        final String _m = "parseCredits(String)";
        LOG.entering(CLASSNAME, _m);

        // Strip out any non-digits.
        final String numericCredits = credits.replaceAll("[^\\d.]", "");
        int result = 0;

        try {
            if (!numericCredits.isEmpty()) {
                result = parseInt(numericCredits);
            }
        } catch (final Exception ex) {
            LOG.log(Level.WARNING, "Could not parse credits: " + credits, ex);
        }

        LOG.exiting(CLASSNAME, _m);
        return result;

    }

    /**
     * @param results
     * @param code
     * @inheritDoc
     */
    @RolesAllowed({USER, FULFILLMENT_SERVICES_USER})
    @Override
    public List<AchievementResult> sort(
            final List<AchievementResult> results,
            final GraduationProgramCode code) {

        // Perform multiple stable sorts over the achievement results.
        final Comparator<AchievementResult> comparator = createComparator(code);
        Collections.sort(results, comparator);

        // Sort the ungraded courses to the end of the list, which will then
        // be pushed up using the assessment comparator.
        final Comparator<AchievementResult> ungraded = createUngradedComparator();
        Collections.sort(results, ungraded);

        // Sort the ReportCourseType.ASSESSMENT values to the end of the
        // list. This could use a comparator chain.
        final Comparator<AchievementResult> assessments = createAssessmentComparator();
        Collections.sort(results, assessments);

        return results;
    }

    /**
     * The sort order for the courses is as follows:
     *
     * For the 1986 and Adult achievement, the courses are sorted only by course
     * code. For the 2004, 1995, and SCCP achievement, the courses are sorted by
     * course level and then by course name.
     *
     * @param code Program code that influences sort order.
     */
    private Comparator<AchievementResult> createComparator(
            final GraduationProgramCode code) {
        final Comparator<AchievementResult> result;

        switch (code) {
            case PROGRAM_1950:
            case PROGRAM_1986:
                result = createAdultComparator();
                break;

            // 1995, 2004, 2018, etc.
            default:
                result = createRegularComparator();
                break;
        }

        return result;
    }

    /**
     * Returns a comparator that can sort by course code.
     *
     * @return A comparator for sorting by course code.
     */
    private Comparator<AchievementResult> createAdultComparator() {
        return new Comparator<AchievementResult>() {
            @Override
            public int compare(
                    final AchievementResult tr1,
                    final AchievementResult tr2) {
                final String reportCourseType1 = getReportCourseType(tr1);
                final String reportCourseType2 = getReportCourseType(tr2);
                final String code1 = getCourseCode(tr1);
                final String code2 = getCourseCode(tr2);

                return new CompareToBuilder()
                        .append(reportCourseType1, reportCourseType2)
                        .append(code1, code2)
                        .toComparison();
            }
        };
    }

    /**
     * Called for non-Adult reports to provide comparators that can perform
     * stable sub-sorts on the achievement results.
     *
     * @return A list of stable comparators that should be executed in order to
     * sort the achievement results.
     */
    private Comparator<AchievementResult> createRegularComparator() {
        return new Comparator<AchievementResult>() {
            @Override
            public int compare(final AchievementResult tr1, final AchievementResult tr2) {
                final int level1 = getCourseLevel(tr1);
                final int level2 = getCourseLevel(tr2);
                final String name1 = getCourseName(tr1);
                final String name2 = getCourseName(tr2);

                return new CompareToBuilder()
                        .append(level1, level2)
                        .append(name1, name2)
                        .toComparison();
            }
        };
    }

    /**
     * Sorts ungraded to the bottom of the list of achievement results.
     *
     * @return A comparator that can sort ungraded results.
     */
    private Comparator<AchievementResult> createUngradedComparator() {
        return new Comparator<AchievementResult>() {
            @Override
            public int compare(final AchievementResult tr1, final AchievementResult tr2) {
                final int level1 = getCourseLevel(tr1);
                final int level2 = getCourseLevel(tr2);

                final int comparison = new CompareToBuilder()
                        .append(level1, level2)
                        .toComparison();

                return SORT_UNGRADED.equals("" + level1)
                        || SORT_UNGRADED.equals("" + level2)
                                ? comparison
                                : 0;

            }
        };
    }

    /**
     * Used to sort assessments to the bottom of the list of achievement results.
     *
     * @return A comparator that can sort assessment results.
     */
    private Comparator<AchievementResult> createAssessmentComparator() {
        return new Comparator<AchievementResult>() {
            @Override
            public int compare(final AchievementResult tr1, final AchievementResult tr2) {
                final int level1 = getCourseLevel(tr1);
                final int level2 = getCourseLevel(tr2);

                final String reportCourseType1 = getReportCourseType(tr1);
                final String reportCourseType2 = getReportCourseType(tr2);

                final String courseCode1 = getCourseCode(tr1);
                final String courseCode2 = getCourseCode(tr2);

                final int comparison = new CompareToBuilder()
                        .append(level1, level2)
                        .append(reportCourseType1, reportCourseType2)
                        .append(courseCode1, courseCode2)
                        .toComparison();

                return ASSESSMENT.isCode(reportCourseType1)
                        || ASSESSMENT.isCode(reportCourseType2)
                                ? comparison
                                : 0;
            }
        };
    }

    /**
     * Convenience method to obtain a sortable course type.
     *
     * @param tr The achievement result containing report course type that
     * control sort order.
     * @return The report course type for the given achievement result.
     */
    private String getReportCourseType(final AchievementResult tr) {
        final Course c = tr.getCourse();
        final String reportCourseType = c == null
                ? PROVINCIALLY_EXAMINABLE.getCode()
                : c.getType();

        return reportCourseType;
    }

    /**
     * Convenience method to obtain a sortable course level.
     *
     * @param tr The achievement result containing course levels to be sorted.
     * @return The course level or "99" if the course has no level (and should
     * therefore be sorted to the bottom).
     */
    private int getCourseLevel(final AchievementResult tr) {
        final Course c = tr.getCourse();
        final String cl = c == null ? "" : c.getLevel().trim();
        final String type = c == null ? "" : c.getType();

        final String level = ASSESSMENT.isCode(type)
                ? SORT_ASSESSMENT
                : SORT_UNGRADED;
        final String courseLevel = cl.isEmpty() ? level : cl;
        int result = 0;

        try {
            // Parse "12A" to 12, "11F" to 11, "10" to 10, for sort purposes.
            final NumberFormat nf = getIntegerInstance();
            result = nf.parse(courseLevel).intValue();
        } catch (final Exception ex) {
            LOG.log(Level.SEVERE,
                    "Could not parse course level into integer: " + courseLevel,
                    ex);
        }

        return result;
    }

    /**
     * Convenience method to obtain a sortable course name.
     *
     * @param tr The achievement result containing course names to be sorted.
     * @return The course name, never null, possibly empty.
     */
    private String getCourseName(final AchievementResult tr) {
        final Course c = tr.getCourse();
        final String name = c == null ? "" : c.getName();

        return nullSafe(name);
    }

    /**
     * Convenience method to obtain a sortable course name.
     *
     * @param tr The achievement result containing course names to be sorted.
     * @return The course name, never null, possibly empty.
     */
    private String getCourseCode(final AchievementResult tr) {
        final Course c = tr.getCourse();
        final String code = c == null ? "" : c.getCode();

        return nullSafe(code);
    }
}
